\section{Implementierung}
\label{sec:Implementierung}
In der Implementierungsphase wird die Software gemäß den Anforderungen und Spezifikationen aus \nameref{sec:Analysephase} und \nameref{sec:Entwurf} Umgesetzt. Der Entwicklungsprozess ist in mehrere Phasen unterteilt, darunter die Programmierung, das Testen und letztlich die Migration ins Livesystem.

Auf Grundlage der in der im \nameref{sec:Entwurf} angefertigten Modelle wurden daraus konkrete Datenstrukturen und Algorithmen umgesetzt. Während der Implementierungsphase wurde besonderes Augenmerk auf die Modularität und Wiederverwendbarkeit des Codes gelegt, um die spätere Erweiterbarkeit der Software zu erleichtern.

\subsection{Kernmodule des Anwesenheitsplaners}
\label{sec:Kernmodule}
Die Entwicklung umfasste mehrerer Kernmodule, die jeweils spezifische Aufgaben und Funktionen der Software erfüllten. Diese werden in den folgenden Sektionen näher vorgestellt. Dabei wird zuerst auf das zu Lösende Problem kurz eingegangen und dann die Lösung für den Anwesenheitsplaner erläutert. Dafür wird \ggfs auch Bezug auf Codesegmente genommen die sich im Anhang befinden. Eine Übersicht über alle Klassen siehe Abbildung \ref{abb:Klassendiagramm} im Anhang.

\subsubsection{AD Manager}
\label{sec:ADManager}
Die Kernfunktionalität des Anwesenheitsplaners ist es, einem Nutzer nach Anmeldung an der Weboberfläche die Anwesenwesenheiten seiner Referatsmitglieder anzuzeigen. Dafür muss dem Programm allerdings bekannt sein in welchem Referat sich der Benutzer befindet, damit für Ihn passende Einträge aus der Datenbank geladen werden können. Diese Informationen stellt die Klasse AD Manager bereit.

Bei der Anmeldung an der Weboberfläche wird der Benutzer durch seine bereits erfolgte Windows Anmeldung durch den IIS als Benutzer erkannt. Dadurch kann über das .NET Framework auf den angemeldeten Benutzer als UserPrincipal Klasse zugreifen. Mit diesem Objekt kann man nun über eine AD Abfrage vom aktuellen Benutzer den AD Wert für department auslesen. Somit kann aus dem AD für den Nutzer das richtige Referat ermittelt werden. Diese Funktionalität wird über GetUserInfo() umgesetzt. Diese Methode gibt noch eine weitere wichtige Information, die SID des Benutzers zurück. Die SID dient zur eineindeutigen Identifizierung des Nutzers und wird in der Datenbank als Primärschlüssel für die Nutzer verwendet. Die gefundenen Informationen werden dann als Dictionary an die Geschäftslogik übergeben. Hier könnten als falls nötig sehr einfach weitere Informationen für die Anwendung angefügt werden.

Die zweite Funktionalität ist die GetPersonsInDepartment(string department) Methode. Diese wird genutzt um für den aktuellen Benutzer die zugehörigen Einträge für alle Rederatsmitglieder zu erhalten. Das Referat des angemeldeten Benutzers wird in die Methode übergeben und diese durchsucht dann mit einem PrincipalSearcher das AD in der SMK OU nach den passenden AD Konten die auch dem Referat angehören und gibt diese zurück.

Der AD Manager wird dann in der Datenlogik aufgerufen und die Rückgabewerte werden für die Interaktion mit der Datenbank benötigt. Ohne eine Verbindung zum AD kann der Anwesenheitsplaner also nicht funktionieren.

\subsubsection{Daten und Datenlogik}
\label{sec:Daten}
Für die persistente und zentrale Speicherung der Anwesenheitsdaten wurde ein relationale Datenbank ausgewählt. Um die Daten aus der Datenbank zu Lesen und neue oder aktualisierte Daten zu schreiben wird eine Schnittstelle zur Datenbank benötigt. Dort wurde sich gegen den Einsatz des weit verbreiteten Entity Frameworks entscheiden, da dieses Framework eine Ausgewachsener Microsoft Object Relational Mapper (ORM) ist. Damit ist es die wichtigste .NET-Datenzugriffs-API. Jedoch kann der Einsatz einer ORM sehr Komplex werden und im Fehlerfall für ungeübte Entwickler zu großen Verzögerungen bei der Fehlerbehebung führen. Deswegen wurde die Mikro-ORM Dapper verwendet.

Dapper ist eine von den Stack Overflow Entwicklern geschriebene Open-Source ORM, die besonderen Fokus auf Optimierung des Datenzugriffs legt. Bei der Nutzung von Dapper schreibt der Entwickler die SQL Befehle selbst und Dapper bietet Transformationsfunktionen wie \zB das einbetten von Objekten in den SQL Befehl oder das Umwandeln von Datensätzen aus der Datenbank in Listen an. Das macht den Datenbankzugriff sehr intuitiv und Fehler können schnell gefunden werden, da die SQL Befehle im Code sichtbar sind. Dapper implementiert auch eingebaute Funktionen gegen SQL Injections und erhöht somit auch die Datensicherheit. Durch die Kombination aus einfachen SQL Befehlen und der sehr guten Transformationsmechanik von Dapper können die Daten sehr einfach aus der Datenbank und auch in die Datenbank geschrieben werden. (vgl. \cite{Dapper})

Alle interaktionen mit der Datenbank wurden über die Einbindung von Dapper gelöst. Dafür wurden die Klassen SQLDataAccess und SQLDataAccessAsync erstellt. Diese beinhalten ausschließlich Methoden zum speichern und laden von Daten unter Verwendung von Type T. Damit konnten Templates für die Methoden zum synchronen und asynchronen Datenzugriff mit der Verwendung von Dapper erstellt werden, die dann der Geschäftslogik zur Verfügung stehen. Ein beispiel für ein solches Tamplate ist im nachfolgendem Codebeispiel \ref{lst:LoadDataAsync} zu sehen.
\\

\begin{lstlisting}[frame=single,caption={Die Methode {\normalfont \ttfamily  LoadDataAsync} aus der SQLDataAccessAsync Klasse}, label={lst:LoadDataAsync}]
public async Task<List<T>> LoadDataAsync<T, U>(string sql, U parameters)
{
    string connectionString = _config.GetConnectionString(ConnectionStringName);

    using (IDbConnection connection = new SqlConnection(connectionString))
    {
        var data = await connection.QueryAsync<T>(sql, parameters);

        return data.ToList();
    }
}
\end{lstlisting}

Die die gesamte Geschäftslogik für das speichern und schreiben der Daten wurde in Klasse UserData ausgelagert. Die Methoden der Klasse UserData bilden eine Operation, wie \zB das Laden der Anwesenheitsdaten eines Nutzers, ab. Dabei sind diese Methoden für genau diesen Anwendungszweck ausgelegt und werden dann bei der Bearbeitung der Events aus dem Frontend ausgelöst.

Am schwierigsten gestaltete sich dabei Implementierung das lesens der Anwesenheitsdatensätze aus der Datenbank. Gespeichert sind diese, wie in Abbildung \ref{abb:ERM} zu sehen mit SID, Datum und Anwesenheitsstatus. Im Model für die View wird das Tupel aus Datum und Anwesenheitsstatus als Dictionary dem Objekt deines Nutzers zugeordnet. Um die Leistung zu verbessern wurde sich dazu entschlossen die Fähigkeit von Dapper, Klassen Attribute auf Datenbank Attribute zu Mappen, auszunutzen indem man durch das geschickte Nutzen der Aliase in SQL mittels Key und Value Zuordnung direkt ein Dictionary befüllt, was dann unter Angabe der SID des zugehörigen User-Objektes dem passenden Objekt als Rückgabewert zugeordnet werden kann.
\\
\begin{lstlisting}[frame=single,caption={Die Methode {\normalfont \ttfamily  GetUserDateStat} aus der UserData Klasse}, label={lst:GetUserDateStat}]
public Task<Dictionary<DateTime, string>> GetUserDateStat(string sid, int month)
{
    string sql = @"
    SELECT DISTINCT A_Datum AS[Key], A_Status AS[Value]
    FROM dbo.Anwesenheit WHERE A_SID = @SID AND MONTH(A_Datum) = @MONTH
    ";

    return _dbasync.LoadDataDictAsync<Dictionary<DateTime, string>, dynamic>(
        sql, new {
            SID = sid, MONTH = month
        });
}
\end{lstlisting}

\subsubsection{View}
\label{sec:View}
Für das Frontend sollte eine einfache Benutzeroberfläche entstehen, die die der Excelliste stark ähnelt und nur die benötigten Funktionalitäten bereitstellt. Es muss also eine Tabelle in HTML gerendert werden, die als Tabellenkopf die Referatsmitglieder als Spalten beinhaltet und die Daten der Tage im Monat. Bei einem Klick auf ein Datumsfeld was in der eigenen Spalte liegt soll dann der zuvor Ausgewählte Anwesenheitsstatus eingetragen werden, der dann weiderum an die Geschäftslogik und damit auch in die Datenbank übertragen wird.

Für die Erstellung der Benutzeroberfläche wurden die vom Framework vorgegebenen ASP.NET Core Razor Pages verwendet. Dabei handelt es sich um auf dem Server gerenderten Benutzeroberfläche. Durch den einsatz des Blazor Server Frameworks in Verbindung mit Razor Pages kann nun View-spezifische Logik für die Seite implementiert werden. Desweiteren verwendet das Framework die Razor Syntax die es ermöglicht Csharp Code direkt in HTML einzubetten. Somit lassen sich leicht Interaktive Benutzeroberflächen erstellen, die auf Csharp Code basieren. (vgl. \cite{Razor}, \cite{RazorSyntax})

Die Geschäftslogik befindet sich angegliedert an die View. Dort sind konkrete Event Handler für die Benutzeroberfläche hinterlegt, die dann \zB mit der Datenbank über die UserData Klasse kommunizieren oder die Berechtigungen des Benutzers prüft. Dabei sind die in das HTML eingebetteten Objekte direkt in der Geschäftslogik integriert. Das ermöglicht die dynamische Generierung der anzuzeigenden Tabelle, indem eine Schleife für jeden in der Liste an Referatsmitgliedern eine eigene Tabellenspalte erzeugt. Für den Nutzer wurde die Klasse UserModel erstellt. Beim initialen Aufruf wird für jedes Referatsmitglied ein Objekt dieser Klasse erzeugt und aus der Datenbank befüllt. Bei Änderungen eines Anwesenheitseintrages auf der Benutzeroberfläche wird die Änderung direkt in das Model des entsprechenden Referatsmitglieds übernommen, da das Objekt direkt in HTML eingebunden ist. Durch das einbetten von UserModel Objekten in die dynamisch generierten Tabellenspalten können vollautomatisch sämtliche Variationen an Anzahl und zusammenstellung des Referates abgebildet werden. %TODO: Codebeispiel im Anhang


\subsection{Tests und Qualitätssicherung}
\label{sec:Tests}

\subsection{Migrationsplan}
\label{sec:Migrationsplan}