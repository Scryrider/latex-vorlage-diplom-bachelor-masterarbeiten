\section{Variantendiskussion}
\label{sec:Variantendiskussion}
Zu Beginn der Variantendiskussion soll eine Marktrecherche durchgeführt werden, um bestehende Lösungen zu Analysieren und auf Eignung zu prüfen. Mit den gewonnen Erkenntnissen soll dann abgewägt werden ob Standartsoftware beschafft werden kann oder eine Eigenentwicklung veranlasst wird.

Für eine etwaige Entwicklung sollen verschidedene Umsetzungsvarianten vorgestellt und verglichen werden um so eine Entscheidung für das weitere Vorgehen zu treffen, welches dann im Entwurf und der Implementation Umgesetzt wird.
%Das erfolgt im Rahmen einer Variantendiskussion, in der verschiedene Ansätze und Technologien zur Umsetzung der Software bewertet werden.

\subsection{Marktrecherche}
\label{sec:Marktrecherche}
Im Rahmen der Marktrecherche wurden drei verschiedene Softwarelösungen für die Anwesenheitsplanung verglichen. Das Ziel dieser Analyse war es, Akquisitionsoptionen für das geplante Softwareprojekt zu ermitteln. Um Entscheidungen über die Eignung treffen zu können, wurden die Softwareprodukte auf den Erfüllungsgrad ausgewählter Anforderungen geprüft und mit einer Bewertungsmatrix, siehe Tabelle \ref{tab:Markterkundung} bewertet, die funktionale- und nichtfunktionale Anforderungen beinhaltete. Dabei wurden die Auswahlkriterien so gewählt und gewichtet das zwingend erforderliche Anforderungen höher gewichtet wurden als optionale Anforderungen.

%TODO:Tabelle muss ordentlich Platziert werden
\begin{table}[htbp]
    \centering
    \includegraphics[width=0.9\textwidth,angle=0]{abb/Markterkundung.pdf}
    \caption[Beschreibung]{ Tabelle Markterkundung}
    \label{tab:Markterkundung}
\end{table}

\subsubsection{An-/Abwesenheitsplaner von Thomas Jäger}
\label{sec:AnAbwesenheitsplaner}
Die erste betrachtete Software, der An-/Abwesenheitsplaner von Thomas Jäger, zeichnete sich durch die besonders intuitive Benutzeroberfläche aus. Bei der Betrachtung der funktionalen Kriterien wurde festgestellt, dass die Software alle benötigten Anforderungen erfüllt und damit für den Einsatz geeignet ist. Negativ zu bewerten ist allerding, das die Software nur als Windows Programm zur Verfügung steht und damit nicht Plattformunabhängig eingesetzt werden kann. Das Programm müsste auf jedem Client PC im SMK installiert werden um die Software für alle Nutzbar zu machen und währe auf moblien Geräten überhaut nicht verfügbar. Damit ergibt sich ein hoher initialer Integrationsaufwand und auch späterer Wartungsaufwand den es zu berücksichtigen gilt. (vgl. \cite{AnAbwesenPlaner})

\subsubsection{timebutler}
\label{sec:timebutler}
Das zweite Programm namens timebutler überzeugte hingegen durch seine Plattformunabhängigkeit da es sich um eine WebApp handelt. Damit könnte man die Software ohne großen Integrationsaufwand im SMK einführen und betrieben. Die Software bietet alle geforderten Funktionalitäten hat jedoch eine komplizierte Benutzeroberfläche und stellt viele Funktionen bereit die nicht benötigt werden. Das resultiert in höheren Anschaffungskosten als bei dem An-/Abwesenheitsplaner von Thomas Jäger. Besonders negativ ist zu bewerten, dass die Software zwar Plattformunabhängig ist jedoch nicht als On-Premises-Software verfügbar ist. Damit müsste auf die Cloud des Anbieters zurückgegriffen werden was nicht gewünscht ist. (vgl. \cite{timebutler})

\subsubsection{Online Office Datei}
\label{sec:OnlineOffice}
Die dritte betrachtete Lösung ist die Verwendung einer Online Office Vorlage. Das würde es ermöglichen, die bereits vorhandenen Excel Tabellen für die Anwesenheitsplanung weiter zu verwenden. Durch das zurückgreifen auf Online Funktionalitäten wie von Microsoft Office356 oder Onlyoffice in Verbindung mit Nextcloud zur Verfügung stehen, kann man den gleichzeitigen Zugriff auf diese Listern erreichen. Damit würde man das Hauptproblem der einfachen Excel Dateien lösen. Doch auch hier müsste man im Falle des einsatzes von Office356 auf die Microsoft Cloud zurückgreifen. Desweiteren gibt es nur begrenzte Möglichkeit diese Excel Listen vor ungewollter Änderungen zu schützen und ein Berechtigungskonzept durchzusetzten.

\subsubsection{Auswertung der Marktrecherche}
\label{sec:AuswertungMarktrecherche}
Nach Betrachtung der drei Programme wurde festgestellt, dass keines der drei für eine Akquisition in frage kommt, da jedes seine individuellen Schwachstellen mit sich bringt. Der An-/Abwesenheitsplaner von Thomas Jäger wäre von allen die beste Option, da es eine benutzerfreundliche Oberfläche, eine solide Funktionalität und eine angemessene Preisgestaltung vereint. Die Plattformunabhängigkeit ist jedoch im SMK ein großer Faktor, da sich das neue Programm möglichst gut in die vorhandene Infrastruktur einfügen soll. Deswegen wurde sich gegen eine Akquisition von Standartsoftware entschieden.

Um die geforderten Funktionalitäten zu erfüllen ohne dabei die Schwachstellen der betrachteten Programme inkauf nehmen zu müssen wurde die Eigenentwicklung der Software an Referat 12 übergeben. Damit soll gewährleistet werden das eine perfekt für da SMK zugeschnittene Lösung entwickelt werden kann und auch in Zukunft durch das hinzufügen von Funktionen aktuell bleibt.

\subsection{Eigenentwicklung}
\label{sec:Eigenentwicklung}

Durch die Eigenentwicklung sollen die spezifischen Anforderungen des SMK präzise Erfüllt und so Kompromisse und Funktionslücken wie bei den verglichenen Programmen vermieden werden. Die Flexibilität und Anpassungsfähigkeit einer Eigenentwicklung ermöglicht eine perfekte Integration mit bestehenden Systemen im SMK. Durch den Entwurf einer an der Excel Tabelle angelehnten Benutzeroberfläche, soll eine intuitive und benutzerfreundliche GUI den Umstieg der Mitarbeiter vereinfachen, was später den bedarf an Schulungen reduziert. Darüber hinaus führt die Eigenentwicklung zur Möglichkeit der internen Wartung und Aktualisierung. Im nachhinein könnten einfache Funktionsupdates hinzugefügt werden um das Anwesenheitsplanungssystem weiterzuentwickeln. Durch die Kontrolle über die genaue Funktionsweise der Entwickelten Software können Datenschutz- und Datensicherheitsaspekte durch individuell implementierte Sicherheitsmaßnahmen getroffen werden.

Bei einer Eigenentwicklung ist jedoch zu beachten, dass wie bei jedem Projekt Risiken wie zu hoher Zeitaufwand oder fehlendes Fachwissen vorhanden sind. Diese müssen auch bei der Wartung des fertigen Systems beachtet werden. Es sollte also während der Entwicklung eine Dokumentation erstellt werde, die auch andere Referatsmitglieder befähigt die Software zu warten und \ggfs weiterzuentwickeln.


\subsection{Umsetzungsvarianten}
\label{sec:Umsetzungsvarianten}


\subsubsection{Benutzerinteraktionsmuster}
\label{sec:Benutzerinteraktionsmuster}
Nach eingehender Analyse der Anforderungen und der Markterkundung sollen verschiedene Umsetzungsvarianten für das geplante Softwareprojekt des Anwesenheitsplaners untersucht werden. Dabei sollen auf bestehende Entwurfsmuster zurückgegriffen und passende ausgewählt werden. Für die Benutzerinteraktion könnte auf das bewährte Model-View-Controller (MVC) Entwurfsmuster zurückgegriffen werden. Dieses Muster ermöglicht die getrennte Entwicklung von Model (Daten und Logik) und Benutzeroberfläche. Die Model Komponente implementiert alle Funktionen die mit Dateninteraktion und Geschäftslogik einher gehen. Die View- und die Controller-Komponente sind dann für alle Benutzerinteraktionen und Visualisierungsaufgaben zuständig. Der Controller bearbeitet die Benutzerinteraktionen und aktualisiert das Model wenn das passende Event von der View ausgelöst wird. Die view wird daraufhin vom Model benachrichtigt das es verändert wurde und aktualisiert die Benutzeroberfläche mit den neuen Daten. (vgl. \cite[S. 847 - 857]{goll2011},\cite{MVC})

Als alternative zum MVC-Muster kann auch das Model-View-ViewModel Muster (MVVM) eingesetzt werden. Es Funktioniert ähnlich wie das MVC Muster mit dem unterschied das die View und das ViewModel, was die benötigten Daten aus dem Model für die View bereitstellt, direkt miteinader verbunden sind. Das ViewModel übernimmt alle für die Darstellung der View benötigten Funktionalitäten und auch die Kommunikation mit dem Model (Daten und Datenlogik). Damit besteht keine Verbindung zwischen View und Model mehr. Das ermöglicht eine komplette Abkopplung von Darstellung und Datenlogik.(vgl. \cite{MVVM})

\subsubsection{Systemarchitektur}
\label{sec:Systemarchitektur}
Neben der Auswahl eines Musters für die Benutzerinteraktion muss auch eine Entscheidung für eine Systemarchitektur getroffen werden. Diese bildet das Rückgrat der Anwendung und sollte daher sorgfältig gewählt werden. Es wurden insbesondere zwei Ansätze für die Entwicklung betrachtet: die monolithische Architektur und die Client-Server-Architektur.

%TODO:Monolith Quelle
Die historisch klassische Form ist die monolithische Architektur. Beim dieser entsteht ein vollkommen unabhängiges System welches zwar mit anderen Diensten oder Datenspeichern interagiert aber die gesamte Anwendung als Einheit bereitzustellt. Das ist vor allem dann geeignet, wenn die Anwendung auf einer spezifischen Plattform ausgeführt werden soll und keine Notwendigkeit für eine verteilte Architektur besteht. Da die monolithische Architektur sowohl das User-Interface als auch die Logik beinhaltet, entfällt der zusätzliche Bedarf an weiteren dedizierten Servern zum bearbeiten der Logik. Nachteil hierbei ist die eingeschränkte Flexibilität, da ein solches Programm an die Plattform gebunden ist für das es Entwickelt wurde.
%TODO:QUelle Sverer Client und SINGE Page App
Die zweite betrachtete Option war die Client-Server-Architektur für Verteilte Systeme, die bei webbasierten Anwendungen oft zum Einsatz kommt. Dabei gibt es \zB bei Single-Page-Applications (SPA) ein Frontend als Benutzerbierfläche welche von einem Backend-Server und einer Datenbank mit Daten versorgt wird. Der Backend-Server ist für die Verarbeitung der Anfragen und die Bereitstellung von Daten zuständig, während die Datenbank die persistente Speicherung der Daten ermöglicht. Der Benutzer interagiert mit der Software über das Frontend, welches die Logik beinhaltet und auf dem Client läuft. Um eine Verbindung zwischen Frontend und Backend herzustellen sendet der Client Anfragen an den Server und erwartet entsprechende Antworten mit Daten. Die Kommunikation zwischen Client und Server erfolgt dann über ein Netzwerkprotokoll wie HTTP. Ein Nachteil ist dabei die ständige Netzwerkabhängigkeit der Clients um den Dienst Nutzen zu können und eine erhöhtes maß an Komplexität in der Entwicklung gegenüber der monolithische Architektur. (vgl. \cite{SPA})

Als weiterentwicklung der Client-Server-Architektur kommen auch noch die Service Orientierte Architektur (SOA) und die Micro Service Architektur in frage. Diese beiden Architekturansätze erlauben das Backend in kleinere einzeldienste zu zerlegen die dann unabhängig voneinander entwickelt, betrieben und skaliert werden können. Das ist ein großer Vorteil bei besonders großen Projekten in denen verschiedene Technologien und Programmiersprechen eingesetzt werden oder ein sehr hohes Maß an Lastverteilung gefordert ist. Für Projekte mit mittel bis kleinem Umfang ist eine solche Architektur jedoch nicht optimal, da das level an Komplexität extrem steigt und die Vorteile der Architekturen warscheinlicht nicht ausgeschöpft werden können. (vgl. \cite{SOA}, \cite{Micro})

\subsubsection{Vergleich}
\label{sec:Vergleich}
Beide der Systemarchitekturansätze könnten für den Anwesenheitsplaner eingesetzt werden. Der monolithische Ansatz könnte durch eine WPF Anwendung für Windows Clients oder einer Serverseitigen WebApp realisiert werden. Der Vorteil dabei ist, dass die Logik und die GUI direkt miteinander verbunden sind und so ein direkter Zugriff auf Benutzereingaben während der Laufzeit möglich ist. Damit benötigt man keine Schnittstellen für die Kommunikation zwischen einem Client und Server. (vgl. \cite{wpf}, \cite{modernApp})

Eine Client-Server-Architektur für eine Single-Page-Application bietet sich ebenfalls an. Die Vorteile davon sind eine umfangreiche Benutzeroberfläche mit vielen Features und theoretisch geringere Netzwerkabhängigkeit, da die Anwendung auf dem Client ausgeführt wird. Im Kontext des Projektes des Anwesenheitsplaners bedeutet das, dass der Anwesenheitsplaner auf jedem Gerät im SMK auch ohne Verbindung zum Server aufgerufen werden kann, dann aber keine Daten geladen werden können. Damit entfällt dieser Vorteil.

Negative Punkte bei einer Client-Server-Architektur sind die erheblich steigende Komplexität, durch die Trennung von Frontend und Backend. Es müssen Schnittstellen, \zB APIs, zur Kommunikation geschaffen werden. Um diese Nachteile auszugleichen sollten moderne Frameworks für die Entwicklung eingesetzt werden. Im Bereich der Webentwicklung ist der Kenntnisstand der Entwickler etwas geringer als bei Desktopanwendungen, was für die Umsetzung Verzögerungen bedeuten könnte. Es sollte also bei diesem Ansatz ein möglichst vertrautes Framework für die Entwicklung verwendet werden.

Ein wichtiger Faktor ist, da viele Bedienstete mit moblien Geräten wie Smartphones und Tablets ausgestattet sind, das eine auf jedem Gerät verfügbare Anwendung entwickelt wird. Damit eignet sich eine Webbasierte Anwendungen perfekt für diesen Fall. Im gegensatz zu Desktop Entwicklungen wie WPF Programme oder Smartphone Apps müssen Webanwendungen nicht installiert werden, das diese von Webservern bereitgestellt und von Browser angezeigt werden.

\subsubsection{Framework}
\label{sec:Framework}
Die Nutzung eines Frameworks für die Entwicklung ermöglicht eine effiziente Entwicklung und erleichtert die Implementierung von Architekturmustern wie \zB MVC. Bei der Auswahl sollten Aspekte wie die Verfügbarkeit von umfangreicher Dokumentation, eine aktive Entwicklergemeinschaft sowie die Integration von bewährten Bibliotheken berücksichtigt werden. Basierend auf diesen Kriterien könnten Frameworks wie Angular, React oder Vue.js in Betracht gezogen werden, die sich in der Webentwicklung bewährt haben und eine breite Unterstützung bieten. Alle diese Frameworks basieren auf Javascript und sind zur Entwicklung von Single-Page-Applications. Diese benötigen geeignete Backendlösungen mit APIs als Schnittstellen, sowie eine  Client-Server-Architektur. (vgl. \cite{SPA}, \cite{serverside})

Als Alternative können Frameworks wie Django, Ruby on Rails oder ASP.NET Blazor verwendet werden. Diese Frameworks ermöglichen die Erstellung von WebApps die Serverseitig laufen. Im gegensatz zu den Clientseitig laufenden WebApps werden alle Events wie \zB Klicks auf Schaltflächen auf dem Server bearbeitet werden. Der Client übermittelt nur das Event. Die Serverseite übernimmt die Verarbeitung der gesamten Logik und Datenverarbeitung inklusive zusammenstellen der Benutzeroberfläche, die dann auf der Clientseite gerendert wird. Durch diese Funktionalität kann der Zugriff auf Datenbanken oder andere Datenquellen ohne das der Client direkten zugriff auf diese hat realisiert werden. Dieser Serverseitigen WebApps können sowohl als verteiltes System oder als monolit System aufgebaut werden. Eine wichtige Rolle bei der wahl des Frameworks spielt die gewünschte Programmiersprache. Das Django Framework läuft mit Python, Ruby on Rails läuft mit Ruby und Blazor läuft \bzw Csharp. (vgl. \cite{BalazorServer}, \cite{serverFrameworks})

\subsubsection{Entscheidung}
\label{sec:Entscheidung}
Nach sorgfältiger Abwägung der Vor- und Nachteile der vorgestellten Umsetzungsvarianten und Architekturmuster wurde beschlossen eine webbasierte Entwicklung und keine Desktopanwendung anzustreben, da Flexibilität und Plattformunabhänigkeit sehr wichtig sind für den einsatz im SMK ist. Es soll eine WebApp entstehen die um Zeit und Aufwand zu minimimen möglichst simpel Aufgebaut sein soll. Da die Nutzerzahl selbst im maximalfall unter 1000 liegt, ist eine gute Skalierbarkeit des Systems kein Faktor. Damit ist die monolithische Systemarchitektur für dieses Projekt eine gute Wahl. Um die Vorteile eines Monolithen ausnutzen zu können sollte sich für eine Serverseitig laufende WebApp entschieden werden, da es die fehleranfälligkeit minimiert weil Clients keine Verbindung zu den Daten im Backend haben.

Aus den vorgestellten Frameworks für Serverseitige WebApps wurde sich gegen den Einsatz von Django und Ruby on Rails entschieden, da keine oder nur sehr wenige Erfahrungen im Umgang mit Python und Ruby vorhanden sind. Das meiste Vorwissen ist im Bereich der Csharp Entwicklung vorhanden, deswegen soll auf das ASP.NET Core Blazor Framework von Microsoft gesetzt werden. Das Blazor Framework kann sowohl ein MVC als auch dem MVVM Modell implementieren. Damit stehen für die Entwicklung beide Optionen offen.




